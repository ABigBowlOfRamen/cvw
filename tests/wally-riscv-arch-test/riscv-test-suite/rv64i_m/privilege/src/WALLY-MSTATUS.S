///////////////////////////////////////////
//
// /imperas-riscv-tests/riscv-test-suite/rv64d/src/WALLY-MSTATUS-rv64d.S
//
// Generated by kmacsaigoren@hmc.edu
// Created on 2021-05-24 13:03:13.519323
//
// Copyright (C) 2021 Harvey Mudd College & Oklahoma State University
// Adapted from Imperas RISCV-TEST_SUITE
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation
// files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, 
// modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software 
// is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES 
// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS 
// BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT 
// OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
///////////////////////////////////////////




######################################################################
# Notes:
#
# The following bitfeilds of mstatus are left untested in this file:
# (as of 25 May 2021)
#
# SXL, UXL (unsupported, hardware depends on XLEN)
# MBE, SBE, UBE (unsupported, endianness is constant)
# TSR, TW, TVM, MXR 
# XS (extra extensions not supported)
# MPRV and SUM will be tested as part of the mmu
####################################################################### 


#include "model_test.h"
#include "arch_test.h"

RVTEST_ISA("RV64I")

.section .text.init
.globl rvtest_entry_point
rvtest_entry_point:
RVMODEL_BOOT

    # ---------------------------------------------------------------------------------------------
    # address for test results
    la x6, wally_signature
		

###########################
# Test Code
###########################

# I sectioned each test into smaller 'functions' with labels to help organize
# and make the code a little more readable

xs_test:
  # test hardwiring of xs to zero
  csrr x8, mstatus
  li x5, 3 # load mask bits into x5
  slli x5, x5, 15
  jal checkBits
  # try to write 11 to xs bits to test hardwiring to zero
  li x5, 3
  slli x5, x5, 15
  csrs mstatus, x5
  jal checkBits

  li x7, 1
  slli x7, x7, 5 # mask out F_SUPPORTED bit
  csrr x5, misa
  and  x5, x5, x7
  bnez x5, float_supported
  j float_unsupported


float_supported:
  # *** KMG 6 July 2021: This test DOES NOT satisfactorily test the fs bit, for now it just chekcs that the initial value is zero
  #                       and that it can be written but not much else.  
  # floating point supported, test, fs, sd bits
  li x5, 3
  slli x5, x5, 13 # load fs mask bits into x5
  jal checkBits # should be zero since, even though float is supported, the unit hasn't been turned on *** is this true?
  jal checkSD
  # force fs to be 11, check SD == 1
  li x5, 3
  slli x5, x5, 13 # load fs mask bits into x5
  csrs mstatus, x5
  jal checkSD
  j test_gpio


float_unsupported:
  # write the same things to memory as if f was supported

  sw x0, 0(x6) # initial FS value is zero
  li x5, 0xD5
  sw x5, 4(x6) # sd = 0
  li x5, 0x5D
  sw x5, 8(x6) # sd = 1
  addi x6, x6, 12


test_gpio:
  # Test MIE bits with GPIO interrupt
  # set trap handler for GPIO interrupt
  la x5, GPIOTrapHandler
  csrw mtvec, x5
  # load interrupt complete flag into x10
  li x10, 0
  # x7 holds 0x6410 if we go through an interrupt and 0x0146 if not.
  li x7, 0x0146
  jal configPLIC
  jal configGPIO
  # set mie
  li x5, 0x800
  csrs mie, x5
  # delegate interrupts to machine mode
  li x5, 0xD00
  csrc mideleg, x5
  # set MIE bit
  li x5, 8
  csrs mstatus, x5
  # Cause GPIO interrupt
  li x5, 0x10060000
  li x28, 0x00080000
  sw x28, 0x0C(x5)
  # wait for GPIO interrupt to finish.
  2: beq x0,x10,2b



test_gpio_disabled:
  # Test MIE bit with GPIO interrupt
  # set trap handler for GPIO interrupt
  la x5, GPIOTrapHandler
  csrw mtvec, x5
  # load interrupt complete flag into x10
  li x10, 0
  # x7 holds 0x6410 if we go through an interrupt and 0x0146 if not.
  li x7, 0x0146
  # clear MIE bit
  li x5, 8
  csrc mstatus, x5
  # Cause GPIO interrupt (shouldn't happen)
  li x5, 0x10060000
  li x28, 0x00080000
  sw x28, 0x0C(x5)
  # Dont need to wait for handler to work since interrupt doesnt happen.
  sw x7, 0(x6)
  addi x6, x6, 4


priv_stack_testM:
  # test the privilege stack using ecall.
  # set trap handler(s)
  la x5, stackTrapHandlerM
  csrw mtvec, x5
  # begin in machine mode.
  csrr x28, mstatus
  # cause m mode exception.
  ecall



priv_stack_testS:
  # test the privilege stack using ecall, handling trap in S mode
  li x5, 1
  slli x5, x5, 9 # mask out ecall_S_mode for medeleg
  csrs medeleg, x5 # delegate traps to S Mode
  # set trap handler(s)
  la x5, stackTrapHandlerS
  csrw stvec, x5
  jal go_supervisor_mode
  csrr x28, sstatus
  # cause s mode exception.
  ecall

  j done


#########################################
# Functions/helpers
#########################################


checkBits:
  # when we load the mask bits into x5, this function stores the masked mstatus to the output
  csrr x8, mstatus
  and x5, x5, x8
  sw x5, 0(x6)
  addi x6, x6, 4
  li x5, 0
  ret

checkBitsS:
  # same as checkbits, but checks the sstatus csr
  csrr x8, sstatus
  and x5, x5, x8
  sw x5, 0(x6)
  addi x6, x6, 4
  li x5, 0
  ret


checkSD:
  # checks SD specially because its the first bit, so we don't have to mask.
  csrr x8, mstatus
  li x5, 0x5D # SD == 1
  bltz x8, sdDirty
  li x5, 0xD5 # SD == 0
sdDirty:
  sw x5, 0(x6)
  addi x6, x6, 4
  ret




go_supervisor_mode:
  # taken from wally final report spr 2021
  li x28, 3
  slli x28, x28, 11
  csrc mstatus, x28  # clear bits 11 and 12 of mstatus
  li x28, 1
  slli x28, x28, 11
  csrs mstatus, x28  # Set bits 11 and 12 of mstatus to 01, meaning
                          # the previous privilege mode is supervisor mode
  auipc x28, 0             # Store the current program counter address in x28
  addi x28, x28, 16         # x28 is now right after the mret instruction
  csrw mepc, x28           # Set mepc to the value in x28
  mret                    # On mret, we go back to the previous privilege mode in
                          # mstatus (S) and go to the next instruction.
  ret # after going into supervisor mode, we need to return from this function


configPLIC:

  # priority threshold = 0
  li x5, 0xC200000
  li x28, 0
  sw x28, 0(x5)
  # source 3 (GPIO) priority = 6
  li x5, 0xC000000
  li x28, 6
  sw x28, 0x0C(x5)
  # source 4 (UART) priority = 7
  li x28, 7
  sw x28, 0x10(x5)
  # enable sources 3,4
  li x5, 0x0C002000
  li x28, 0b11000
  sw x28, 0(x5)
  ret



configGPIO:

  # enable all inputs
  li x5, 0x10060000
  li x28, 0xFFFFFFFF
  sw x28, 0x04(x5)
  # enable all outputs
  sw x28, 0x08(x5)
  # enable all rising edge interrupts
  sw x28, 0x18(x5)
  # set MEIE
  li x5, 0x800
  csrs mie, x5
  ret


stackTrapHandlerM:
  # trap handler for when we use ecall to test the privilege mode stack.
  # x28 holds the previous mstatus value
  csrr x29, mstatus
  li x5, 3
  slli x5, x5, 11 # mask out MPP bits
  jal checkBits # mpp should be 11

  li x5, 1
  slli x5, x5, 8 # mask out spp bits
  jal checkBits  # spp should be zero.

  li x5, 1
  slli x5, x5, 3 # mask out MIE bit
  jal checkBits  # MIE should be set to zero

  li x5, 1
  slli x5, x5, 7 # mask out MPIE bit
  and x5, x29, x5
  li x7, 1
  slli x7, x7, 3 # mask out previous MIE bit
  and x7, x7, x28
  slli x7, x7, 4 # put the bits in the same place 
  xor x5, x7, x5 # check if theyre the same
  sw x5, 0(x6) # should be all zeros.
  addi x6, x6, 4

  li x5, 1
  slli x5, x5, 5 # mask out SPIE bit
  and x5, x29, x5
  li x7, 2 # mask out previous SIE bit
  and x7, x7, x28
  slli x7, x7, 4 # put the bits in the same place 
  xor x5, x7, x5 # check if theyre the same
  sw x5, 0(x6) # should be all zeros.
  addi x6, x6, 4

  csrr x29, mepc
  addi x29, x29, 4
  csrw mepc, x29

  mret

stackTrapHandlerS:
  # trap handler for when we use ecall to test the privilege mode stack.
  # x28 holds the previous sstatus value
  csrr x29, sstatus

  li x5, 1
  slli x5, x5, 8 # mask out spp bit
  jal checkBitsS  # spp should be 1.

  
  li x5, 1
  slli x5, x5, 1 # mask out SIE bit
  jal checkBitsS  # SIE should be set to zero

  li x5, 1
  slli x5, x5, 5 # mask out SPIE bit
  and x5, x29, x5
  li x7, 2 # mask out previous SIE bit
  and x7, x7, x28
  slli x7, x7, 4 # put the bits in the same place 
  xor x5, x7, x5 # check if theyre the same
  sw x5, 0(x6) # should be all zeros.
  addi x6, x6, 4

  # set return location to AFTER the ecall.
  csrr x29, sepc
  addi x29, x29, 4
  csrw sepc, x29

  sret




GPIOTrapHandler:

  # several 'set low' reads to indicate we've handled the interrupt.
  # 0x10: input_val 
  li x5, 0x10060000
  lw x7, 0x00(x5)
  # 0x14: output_val 
  lw x7, 0x0C(x5)
  # 0x18: incoming rise_ip 
  lw x7, 0x1C(x5)
  # 0x1C: serviced rise_ip = 0
  sw x7, 0x1C(x5)
  lw x7, 0x1C(x5)
  # 0x20: incoming fall_ip 
  lw x7, 0x24(x5)
  # 0x24: serviced fall_ip = 0
  sw x7, 0x24(x5)
  lw x7, 0x24(x5)
  # 0x28: incoming high_ip 
  lw x7, 0x2C(x5)
  # 0x2C: serviced high_ip = 0
  sw x7, 0x2C(x5)
  lw x7, 0x2C(x5)
  # 0x30: incoming low_ip 
  lw x7, 0x34(x5)

  # 0x34: serviced low_ip  = 0
  sw x7, 0x34(x5)
  lw x7, 0x34(x5)


  # check PLIC claim register 
  # (has the side effect of telling the PLIC that this interrupt is being handled)
  li x5, 0x0C200004
  lw x7, 0(x5)

  # skip a lot of the GPIO handling because this test doesnt care about the actual input
  # and receiving the value from GPIO, we just care about whther the interrupt happened.
  li x7, 0x6410 # "gpio"
  sw x7, 0(x6)
  addi x6, x6, 4

  # Signal to PLIC that the trap was handled.
  li x5, 0x0C200004
  li x7, 3
  sw x7, 0(x5)

  # reset GPIO, show interrupt was handled
  li x5, 0x10060000
  li x28, 0x00080000
  sw x28, 0x1C(x5)


  li x10, 0x76 # random nonzero number to break the bne x0 loop
  mret

done:
RVMODEL_HALT

RVTEST_DATA_BEGIN
RVTEST_DATA_END

RVMODEL_DATA_BEGIN
# signature output
wally_signature:
.fill 16, 4, -1

#ifdef rvtest_mtrap_routine
mtrap_sigptr:
    .fill 64*(XLEN/32),4,0xdeadbeef
#endif

#ifdef rvtest_gpr_save
gpr_save:
    .fill 32*(XLEN/32),4,0xdeadbeef
#endif
RVMODEL_DATA_END
