1. Decide whether to use ahblite or busdp implements burst.
    a. If ahb, move capture register for the line into ahblite. Busdp will need to indicate length of read/write (probably using HBURST signal) *** Ross likes this one.
    b. BusDP generates ALL intermediate addresses. Is still responsible for controlling HBURST. *** David likes this one, Ross from an efficiency standpoint too

2. (Don't) ignore entire CPU and cache and busdp. Focus on making AHBlite that can implement burst and non-burst mode.
    a. modify ifu to use burst. immediately detects if its working.
        i. make sure we collect the right stuff from memory. (gets captured into ahblite's capture register)
    b. modify busdp to use new ahblite interface.
        i. remove capture register.
        ii. modify fsm to expect one ack, not however many it expects right now
        iii. increase width of data coming from ahb to cache line length.
    c. modify cache to work with new ahb interface.
        i. output full cacheline to ahb
        ii. word select multiplexer (subcachelineread + lines before it) will be controlled by word count in ahb.
            v. ONLY NEED MUX.

// Don't do A
        
  assign CntEn = PreCntEn & LSUBusAck | (DCacheFetchLine | DCacheWriteLine);
  assign CntReset = BusCurrState == STATE_BUS_READY & ~(DCacheFetchLine | DCacheWriteLine);

    Have BusDP output HBURST (Done) and HTRANS (*** TODO) [SEQ/NONSEQ/IDLE]

    Add delayed word count flop for internal capture of HRDATA and pushing HWDATA
        WordCount is used to select which word to write. send current to cache.
    BusDP handles HWDATA and just pushes it to ahblite.sv